## 五层重要协议

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g82cg6f57yj30hl09kaao.jpg)

我们采用中和OSI和TCP/IP协议的五层协议体系结构。

### 应用层

------

协议比方说DNS域名解析

### 运输层

------

TCP：面向连接的，可靠的数据传输服务。

UDP：无连接，不保证数据传输的可靠性。

### 网络层

------

把运输层产生的报文段或用户数据报封装成分组和包进行传送。

### 数据链路层

------

两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。

### 物理层

------

实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。

## TCP三次握手和四次挥手

### 图解三次握手

### ![](https://tva1.sinaimg.cn/large/006y8mN6ly1g82cst4hdpj30o00c7mxr.jpg)

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g82csy5kzyj30f20bv74c.jpg)

### 为什么要三次握手

双方确认自己与对方的发送与接收是正常的。

### 接收端为什么要传回SYN

接收端传回发送端所发送的SYN是为了告诉发送端，我接收到的信息确实就是你所发送的信号。

### 接收方传了SYN，为啥还要传ACK

双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。

### 图解四次挥手

![TCP四次挥手](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

### 为什么要四次挥手

看图说话。

### TCP、UDP协议的区别

传送数据之前需不需要建立连接，可靠不可靠。UDP：QQ、直播等等。TCP：文件传输、接收和发送邮件等等场景。

### TCP协议如何保证可靠传输

1、流量控制，当接收方来不及处理发送方的消息，能提示发送方降低发送的速率；

2、拥塞控制，当网络繁忙时，减少数据的发送；

3、每发送完一个分组就停止发送，等待对方确认；

4、超时重传，当发出一个段后，启动一个定时器，等待目的端确认收到这个报文段，如果不能及时收到一个报文段，将重发这个报文段。

### 在浏览器输入URL地址->显示主页的过程

[参考文章](https://segmentfault.com/a/1190000006879700)

1、DNS解析

2、TCP连接

3、发送HTTP请求

4、服务器处理请求返回HTTP报文

5、浏览器解析渲染页面

6、连接结束

### HTTP长连接、短连接

在HTTP1.0中默认使用短连接，客户端和服务端每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。

从1.1起，默认使用长连接，用以保持连接特性。响应头加入这行代码：

~~~java
Connection:keep-alive
~~~

### cookie和session

HTTP是无状态的。session机制来保存用户状态，比方说购物车场景。session保存在内存或者数据库中，大部分情况下，我们在cookie中附加一个session ID来跟踪这个session。

cookie：一般用于保存用户的登录信息，登录成功，存放一个token放到cookie里面。存放在客户端。

session：记录用户的状态，购物车场景。存放在服务端。

### HTTP1.0和1.1的主要区别

1、短链接还是长连接；

2、新增错误状态码；

3、缓存处理策略更多；

4、带宽优化。

### URI和URL的区别是什么

- URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。
- URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。

URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。

### HTTP和HTTPS的区别

1、端口，80和443

2、安全性和资源消耗：明文和加密（对称加密，秘钥是通过非对称加密获得），HTTPS资源消耗的更加多。

#### 一步一步还原HTTPS的设计过程

安全性考虑：

> A发送给B的hello消息包，即使被中间人拦截了，也无法直到消息的内容

于是乎，我们想到的解决方案是加密。

> A与B的通信内容，有且只有A和B有能力看到通信的真正内容

作出选择

> 使用对称秘钥进行加密，既能使用对称加密算法，又不公开秘钥？

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g8soiwhghnj30lo0eogox.jpg)

如何确定对称加密算法？我们服务端怎么告诉客户端该使用哪种对称加密算法，并且加密秘钥是啥？**当然是通过协商！**

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g8sokxce09j30vs0j4jy6.jpg)

协商的过程是没有加密的，还是会被中间人拦截，那我们对这个协商过程进行加密好了？？于是就陷入了鸡生蛋，蛋生鸡的问题了。

如何对协商过程进行加密

------

非对称加密！私钥加密，公钥解密。或者公钥加密，私钥解密。这就是HTTPS同时使用对称加密算法和非对称加密算法的原因！

客户端如何得到公钥（私钥保存在服务端）

------

服务端将公钥发送给每一个客户端

公钥被掉包了怎么办？

------

引入第三方结构，公钥是第三方机构（数字证书）用私钥进行加密了，我们客户端只要使用了第三方机构的公钥进行解密，解密成功，代表这个公钥没有被掉包，可以安全使用。

总结

------

HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g8sp2g3cnij30lg0ne74g.jpg)

这个图需要进行补充下，返回证书~~（公钥）~~这一步的解释是：防止公钥被掉包，返回的是证书（里边的公钥是被第三方机构用私钥进行加密的），客户端用第三方机构的公钥进行解密得到公钥（解密成功证明没有被掉包，解密失败表明被掉包了）。