### 誉道科技-1105

建立索引规则

group by使用

RabbitMQ

### 行云跨境电商

秒杀设计？

1. 前端接收请求，生产一条MQ的消息，发送到rabbitmq，process应用监听并且处理request，请求处理完了，发送一条消息到rabbit，request应用监听并且处理，告诉消费者是否抢到商品，可以增加process应用，增加处理能力。
2. 详细版本
   - 对现有网站业务造成冲击：分开部署
   - 突然增加的网络及服务器宽带：运行商租借带宽
   - 秒杀页面静态化：防止用户不断进行点击
   - 尽量将请求拦截在系统上游：传统秒杀系统之所以挂，请求都压倒了后端数据层，数据读写锁冲突严重，并发高响应慢，几乎所有请求都超时，流量虽大，下单成功的有效流量甚小【一趟火车其实只有2000张票，200w个人来买，基本没有人能买成功，请求有效率为0】。
   - 读多写少使用Redis：这是一个典型的**读多写少**的应用场景【一趟火车其实只有2000张票，200w个人来买，最多2000个人下单成功，其他人都是查询库存，写比例只有0.1%，读比例占99.9%】，**非常适合使用缓存**。
   - 前端层设计：秒杀页面的展示、倒计时、前端层的请求拦截
   - 服务层设计：高级黑客，只能服务层进行拦截，对于写请求，通过队列，每次只通过有限的写请求去数据层，如果库存不够则队列里的写请求全部返回”已售完“。对于读请求，用Redis来抗，单机每秒几万都是没啥问题的。
   - 并发队列的选择：ConcurrentLinkedQueue（入队需求要远大于出队需求），cas无锁队列实现，性能高。然后定义一个ArrayBlockingQueue来暂存有可能成功的用户请求，单线程操作，

为什么volatile不保证原子性？

比方说：i++;这个代码可以分为3个步骤：1、从主内存中取值；2、执行+1；3、值重新写回到主内存。使用volatile修饰，它只能保证第一步是从主内存取得最新值和指令不被重排序。例如：从主内存取到最新值i=1，线程A执行完+1操作（i=2），如果这个时候线程A让出时间片，其他线程修改i的值为5，线程A继续执行，把i=2写回到主内存中，这个时候就线程不安全了，主要原因就是把值写回到主内存时，并没有判断主内存的最新值和之前取到的值一样就写回了内存了，所以volatile仅仅用来保证该变量对所有线程的可见性，但不保证原子性。

### 阿里系公司

zookeeper选举机制、Redis哨兵选举机制

### 数立科技

项目、spring声明周期、TCP

### 其他

Redis的zset的底层数据结构

jdk1.8的新特性：

> - **Lambda表达式**：代码更加简洁，本质上就是一段匿名内部类，也可以是一段可以传递的代码
> - 函数式接口：接口中仅仅只有一个抽象方法。为了让我们更加方便的使用lambda表达式。
> - Stream API：串行流和并行流（基于forkjoin框架，大任务拆分成小任务，再将小任务运算结果进行合并），filter、limit、skip、sorted、map（生成新的流通过map映射）、match、reduce、collect。
> - 接口中的默认方法和静态方法
> - 新时间日期API：不可变的，可以使用于多线程的环境下。
> - 多线程相关：并行流（list.parallelStream）、增强completableFuture、读写锁的改进StampedLock（先尝试使用乐观读，如果在这期间，有线程申请到了写锁，乐观读就会失效，一方面可以再次尝试，另一方面可以把乐观读升级成悲观读）、LondAdder：仿造CHM，分片的方式，比方说将atomicInteger的value，分离成一个数组，每个线程访问，通过hash等算法映射到其中一个数字进行计算，而最终的计算结果，是这个数组的求和累加。
> - 内存分代：移除了永久代，用元空间代替。

限流相关：

限流方式：

> - 限制总并发数：数据库连接池、线程池。
> - 限制瞬时并发数：Nginx的limit_conn模块。
> - 限制时间窗口内的平均速率：如Guava的RateLimiter
> - 其他：限制MQ的消费速率等等

限流算法：

> - 滑动窗口：控制发送速度，以免接受方的缓存不够大，而导致溢出。
>
> ![](https://tva1.sinaimg.cn/large/006y8mN6gy1g95ggs1ubvj31ho0i6my6.jpg)
>
> - 漏桶：往桶里面注水，水会固定的速率往外漏水，如果桶满了，水会溢出来，溢出来的水直接抛弃，或者暂时拦截上方水的向下流动，等待桶中的一部分水漏走后，再放行上方水。
> - 令牌桶（能够解决突发流量）：系统会按照一定的速度往生成令牌，并将其放置到令牌桶中，可以将令牌桶想象成一个缓冲区（Redis的list数据结构，或者java的queue），当缓冲区填满了，新生成的令牌会被扔掉。请求的速率等于令牌流的速率：无延迟地执行逻辑；请求的速率小于令牌桶的速率：无延迟地执行逻辑；请求的速率大于令牌流的速率：熔断、丢包、拒绝响应。

MVCC

> 简单理解：在每一行数据增加两个字段（隐藏的），一个是保存了行的创建版本号，一个是保存了行的删除版本号，没开始一个事务，系统版本号都会自动递增。读取的时候，当前事务版本号必须要大于行的创建版本号并且小于行的删除版本号。
>
> 优点：比纯粹加锁更加高效，不阻塞，提高并发度。
>
> **MVCC只在读已提交和可重复读两个隔离级别下工作！**
>
> 个人理解（可能有偏差）：undo log实现多版本并发控制解决了脏读（读已提交的隔离级别）。MVCC实现了可重复读。

dubbo和springcloud的区别

> - 背景：一个是阿里巴巴开源的，毕竟是商业公司，dubbo符合阿里巴巴业务体系。spring家族的产品，spring专注于企业级开源框架的研发，不管是国内还是国外使用非常广泛，通用、开源、稳健的框架；
> - 社区活跃度来说，dubbo曾经有一阵子停止维护了，被springcloud赶超，springcloud仍然不断发展；
> - dubbo框架专注于服务之间的治理，如果我们要引入配置中心，需要自己去集成。springcloud几乎考虑了服务治理的方方面面，开发起来非常的便利和简单；
> - 性能这一块的比较，rpc对HTTP
>
> 总结：springcloud是整机，dubbo需要自己组装；整机的性能有保证，组装的机子更自由。