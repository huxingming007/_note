### 誉道科技-1105

建立索引规则

group by使用

RabbitMQ

### 行云跨境电商

秒杀设计？

1. 前端接收请求，生产一条MQ的消息，发送到rabbitmq，process应用监听并且处理request，请求处理完了，发送一条消息到rabbit，request应用监听并且处理，告诉消费者是否抢到商品，可以增加process应用，增加处理能力。
2. 详细版本
   - 对现有网站业务造成冲击：分开部署
   - 突然增加的网络及服务器宽带：运行商租借带宽
   - 秒杀页面静态化：防止用户不断进行点击
   - 尽量将请求拦截在系统上游：传统秒杀系统之所以挂，请求都压倒了后端数据层，数据读写锁冲突严重，并发高响应慢，几乎所有请求都超时，流量虽大，下单成功的有效流量甚小【一趟火车其实只有2000张票，200w个人来买，基本没有人能买成功，请求有效率为0】。
   - 读多写少使用Redis：这是一个典型的**读多写少**的应用场景【一趟火车其实只有2000张票，200w个人来买，最多2000个人下单成功，其他人都是查询库存，写比例只有0.1%，读比例占99.9%】，**非常适合使用缓存**。
   - 前端层设计：秒杀页面的展示、倒计时、前端层的请求拦截
   - 服务层设计：高级黑客，只能服务层进行拦截，对于写请求，通过队列，每次只通过有限的写请求去数据层，如果库存不够则队列里的写请求全部返回”已售完“。对于读请求，用Redis来抗，单机每秒几万都是没啥问题的。
   - 并发队列的选择：ConcurrentLinkedQueue（入队需求要远大于出队需求），cas无锁队列实现，性能高。然后定义一个ArrayBlockingQueue来暂存有可能成功的用户请求，单线程操作，

为什么volatile不保证原子性？

比方说：i++;这个代码可以分为3个步骤：1、从主内存中取值；2、执行+1；3、值重新写回到主内存。使用volatile修饰，它只能保证第一步是从主内存取得最新值和指令不被重排序。例如：从主内存取到最新值i=1，线程A执行完+1操作（i=2），如果这个时候线程A让出时间片，其他线程修改i的值为5，线程A继续执行，把i=2写回到主内存中，这个时候就线程不安全了，主要原因就是把值写回到主内存时，并没有判断主内存的最新值和之前取到的值一样就写回了内存了，所以volatile仅仅用来保证该变量对所有线程的可见性，但不保证原子性。

### 阿里系公司

zookeeper选举机制、Redis哨兵选举机制

### 数立科技

项目、spring声明周期、TCP