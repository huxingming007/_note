### 同步与异步

发起一个调用后，是否要等到处理完毕才能返回。异步可以基于回调机制来通知调用者其返回结果。

### 阻塞和非阻塞

当前线程是否被挂起。

> 烧水的案例，等着水开（同步阻塞），时不时的过来看一眼水是否开（同步非阻塞），听到响声后知道水开了（异步非阻塞）

### BIO

while循环accept客户端的连接，进行读写操作，阻塞的，其他客户端只能进行等待。如果要支持多线程的话，一个连接，一个线程。系统资源可以控制的话并且减少创建和销毁线程的开销，使用线程池进行优化改善。

### NIO

非阻塞、3个核心组件：buffer、channel、selector

#### 非阻塞

单线程从通道中读取数据，若没有数据可用时候，可以处理做别的事情。单线程写入数据到通道，不需要等到完全写入，该线程同时可以去做别的事情。线程通常将非阻塞IO的空闲时间用于在其他通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道。因此NIO可以让服务端使用一个或者有限几个线程来同时处理连接到服务端的所有客户端。

#### buffer缓冲区

IO是面向流，NIO是面向缓冲区

#### channel通道

NIO是通过通道进行读写数据

#### selector选择器

使单个线程处理多个通道。单个线程阻塞在selector.select();当某个通道（必须先注册到选择器上面）有连接事件、读事件、写事件的时候，这个方法会返回，会去处理相应的事件。

### AIO

异步非阻塞，基于事件和回调机制实现的，当后台处理完成后，操作系统会通知相应的线程进行后续操作。

### 五种IO模型

[举例](https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247484746&idx=1&sn=c0a7f9129d780786cabfcac0a8aa6bb7&source=41#wechat_redirect)

鱼塘中的鱼通过鱼钩转移到鱼篓里面

硬盘中的文件通过内核拷贝到用户空间里面

#### 阻塞IO

应用进程调用内核，数据没有准备好，一直阻塞，知道复制完成再返回。

#### 非阻塞IO

应用进程反复调用内核，数据没有准备好，不阻塞，直接返回。

#### 信号驱动IO

注册一个信号驱动函数，当内核数据准备好时，发送一个信号给进程，然后进程来进行调用。

#### IO复用

提高钓鱼效率，多准备几根鱼竿。多个通道注册到一个选择器上面，阻塞等待通道上面的发生的事件（连接、读、写），有事件发生，立马返回，然后再进行系统调用。

#### 异步IO模型

上面几种都是同步IO模型，因为把鱼钓起来放进鱼篓（数据拷贝），都是需要人工主动去做的，并不是鱼竿自己完成的。如果使用高科技鱼竿，即全自动鱼竿，那就是异步IO模型了。进程调用内核，直接返回，复制完成后再通知到进程。

[举例：钓鱼的例子](https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247484746&idx=1&sn=c0a7f9129d780786cabfcac0a8aa6bb7&source=41#wechat_redirect)