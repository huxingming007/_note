### 前言

------

目前大部分的NIO框架或者容器都是实现了Reactor模式，Tomcat、Jetty的NIO都是实现了Reactor模式，Netty和Mina是两套NIO的框架，也分别对Java NIO进行了二次封装实现了Reactor模式。

### 演进过程

------

1、最开始的网络编程，一个while循环，不断接收客户端的连接，当这个客户端没有处理完成之前，无法接收其他客户端的连接，最最原始的BIO模型。

2、继续改进，一个线程一个连接，while循环里面，每来一个客户端连接，就创建一个线程，这个线程就服务与这个客户端后续的读写操作。优点：连接不阻塞了；缺点：线程的反复创建和销毁牺牲性能、并发量大并且没有控制的话系统资源会被消耗殆尽；

3、继续改进，大家都能想的到的方式，采用线程池。优点：线程反复利用，节约了线程创建和销毁产生的性能开销，线程个数和队列个数可以进行控制，避免了系统资源被耗尽的危险；缺点：显而易见，无法处理高并发的场景，在单机1000以下连接的情况下，还能搓搓有余，当上万，甚至上百万，只能干瞪眼了；

4、继续改进，reactor模式就横空出去，解决3遇到的问题。

### 正文开始

------

Reactor模式是事件驱动的，简单理解，它是基于java NIO的，抽象出来两个组件：reactor和handler。

- reactor：负责响应IO事件，当检测到一个新的事件，将其发送给相应的handler去处理，新的事情包括连接建立就绪、读就绪、写就绪等。
- handler：将自身和事件绑定，负责事情的处理，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。
- 一句话概括：reactor监听客户端的连接请求，把请求分派给各自的handler做处理。

单线程的Reactor模式：reactor线程和handler线程是同一个，handler的阻塞会导致其他handler的阻塞，导致acceptor也被阻塞，基本上很少使用这种模型。

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g8250ktth0j30fe07fdg6.jpg)

多线程的Reactor模式：reactor线程仍旧可以是同一个，handler事件放入线程池里面进行处理。

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g8251p2j6nj30fe09kwey.jpg)

继续改进：reactor线程采用多线程的方式。

reactor的优点：分而治之，将任务进行拆分，由专门的人负责专门的任务，有限的几个线程就可以处理高并发量的请求。我觉得最大的提升就是减少了性能的使用，即不需要每个client对应一个线程，reactor机制中每次读写已经能保证非阻塞读写，这里可以减少一些线程的使用，减少线程的使用对性能有很大的影响。

[举例：银行的例子](https://mp.weixin.qq.com/s/dFumpp1wBO1NWes3AxVBRw)

