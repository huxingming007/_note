此篇幅最主要是理JVM的重点，并且查漏补缺，具体细节不会展示出来。

## JVM内存区域

### 运行时数据区域

JDK1.8之前和之后有差异：取消了永久代，用元空间进行代替，永久代受限于固定大小的限制，很难进行调整，而元空间使用的是直接内存，受本机可用内存的限制，基本上不会发生OOM。

#### 程序计数器

线程私有。字节码指令（分支、跳转、循环、异常处理、线程恢复等）都需要程序计数器的帮忙，在多线程情况下，程序计算器记录当前线程执行的位置，从而当线程被切换回来的时候能够知道上次运行到了哪儿。

#### 虚拟机栈

线程私有。由一个个栈帧组成，每个栈帧都拥有：局部变量表（输入参数和输出参数以及方法内的变量类型，在编译期完成分配，一个栈帧的内存大小是固定的可知的）、操作数栈（记录出栈、入栈的操作）、动态链接、方法出口信息。

两种异常：StackOverFlowError（请求栈的深度超过当前虚拟机栈最大深读，比方说递归调用） 和 OutOfMemoryError（当线程请求栈，内存用完了，比方说创建非常多的线程。栈的大小=JVM进程的大小-堆的大小-方法区的大小）

#### 本地方法栈

为native方法所服务。

#### 堆

线程共享，存放对象的实例。垃圾收集器管理的主要区域。新生代（Eden、from、to）、老年代。

#### 方法区

线程共享。类信息、常量、静态变量。在Hotspot虚拟机用永久代实现了方法区。

元空间为什么替代永久代？

永久代受JVM本身设置的固定大小的限制，无法进行调整，而元空间使用的是直接内存，受本机最大内存的限制，基本上不会发生OOM。永久代的大小比较难以指定。**直接内存减少了垃圾回收的工作**。加快了复制的速度，因为堆内在flush到远程时，会先复制到直接内存（堆外内存），然后再发送，而直接内存相当于省略了这个工作。（**堆内存中的数据，如果要做IO操作，会先复制到直接内存，再利用本地IO处理**）

#### 运行时常量池

它是属于方法区的一部分。**class文件**除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用），这常量池信息加载进内存，放到了方法区。当然运行的时候，也是可以把字符串放到常量池中，比如说string的intern方法。

> 1.6及之前：有永久代，常量池1.6在方法区
>
> 1.7：有永久代，但已经逐步”去永久代”，常量池在堆
>
> 1.8及其以后：无永久代，常量池在元空间

常量池的优点：节省了反复创建对象和销毁对象的性能成本，实现了对象的共享，节省了空间。节省了性能，比较字符串时候，==比equals()快。

#### 直接内存

不是虚拟机运行时区域的一部分。NIO，基于channel与buffer，直接使用native函数库直接分配堆外内存，然后通过一个存储在java堆中的一个对象作为这块内存的引用。

### Hotspot虚拟机对象探秘

#### 对象的创建

类加载检查、分配内存、初始化零值、设置对象头、执行init方法。

**分配内存：**指针碰撞和空闲列表，最主要看内存是否规整，取决于垃圾收集器是否采用了标记整理算法。

**内存分配产生的并发问题：**cas+失败重试策略、TLAB每个线程都在Eden区有一块很小的区域用于放本线程产生的对象，因为是线程私有的，可以消除同步，对GC友好。首先在TLAB分配，放不下了只能使用CAS的策略。

初始化零值：保证对象的实例字段在java代码中不赋初始值也能直接使用。

设置对象头：包括MarkWord（hashcode、GC分代年龄、锁信息（持有锁的线程id、是否是偏向锁、锁的状态标志位））+类元数据（知道这个对象是哪个类的实例）。

执行init方法：按照程序员的意图进行初始化。

init方法和clinit方法的区别：对象构造器和类构造器，new对象时调用和类加载阶段初始化时调用，构造函数调用和静态代码块的调用。

#### 对象的内存布局

对象头、实例数据和对齐填充。

#### 对象的访问定位

句柄（对象位置发生改变，只需要更改句柄就行）、直接指针（速度快，节省了一次指针定位的开销）。

## JVM垃圾回收

### 揭开JVM内存分配与回收神秘面纱

#### 对象优先在Eden区分配

当分配完了，触发一次minor GC，把Eden+from放入到to中，如果放不下，因为有分配担保机制的存在，它会放到老年代中。

分配担保机制：Eden区放不下的时候，需要考虑触发minor GC还是full GC，如果老年代连续空间大于新生代，那么触发minor GC是安全的，如果小于，那就是危险的，这个时候得看是否允许担保失败，如果允许，只要老年代连续空间大于历次晋升老年代的新生代大小，那就触发minor GC，尽管是有风险的。如果小于或者不允许担保失败，那就触发一次full GC。JDK6之后的某个版本，只要连续空间大于历次晋升的大小，就触发minor GC。

#### 大对象直接进入老年代

to中放不下，放到老年代，会带来效率问题。我觉得最主要得看系统产生的大对象，是否短命，如果短命的多，这些大对象最好能在新生代回收掉，如果直接进入老年代，会占用老年代的空间。如果长命的多，这些大对象可以直接进入老年代，避免在新生代来回复制，并且有可能发生promtion fail 触发cms的concurrent mode fail。

#### 长期存活的对象放入老年代

age计数器，到达一定岁数，默认是15，会进入老年代。每经过一次minor GC，岁数就会加1。

#### 动态年龄判定

survivor空间中，如果相同岁数的对象大小超过了survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需要达到要求的年龄。

### 对象已经死亡

怎么判断对象是否已经死亡？引用计数法、可达性分析（GC ROOTS对象作为起点，向下搜索，看是否有引用链）。

GC ROOTS：局部变量、方法区中常量、方法区中静态变量。

强引用：必不可少，宁愿抛出OOM，也不会回收它；

软引用：可有可无，内存足够的话，是不会回收它；

弱引用：可有可无，垃圾回收器线程扫描到的话，就会被回收它；

虚引用：任何时候都会被回收。

不可达的对象并非非死不可：如果对象重写了finalize方法，回收之前，系统会调用finalize方法，只会调用一次，如果在finalize中，此对象又有引用了，垃圾回收器就会不回收它，相当于自救了一次。一般情况下，不太会使用，finalize能做的活try finally也会做。

如何判断是一个无用的类：1、类的实例都已经被回收；2、加载该类的classloader已经被回收；3、java.lang.class对象没有在任何地方引用。

### 垃圾收集算法

标记清除算法、复制算法、标记整理算法、分代收集算法。

#### 标记清除算法

最基础的算法，效率不高，并且会产生内存碎片，导致以后分配大对象时，无法找到连续的空间不得不提前触发一次垃圾回收。

#### 复制算法

使用于新生代，有两块一模一样的空间，只使用其中的一块，GC时把存活的对象移到另外一块，原先那块一次性清理掉，效率高，并且没有内存碎片。当回收时，会把survivor和Eden还存活的对象移到另外一块survivor，最后清理掉Eden区和原先survivor。Eden与survivor比例默认为8：1，只有百分之10的内存是被浪费掉的。缺点是浪费一块内存，但是也不会太多。老年代可以为其进行分配担保。

#### 标记-整理

适合于老年代，没有内存碎片。

#### 分代收集

**根据各个年代的特点选择合适的垃圾收集算法。**对新生代采用复制算法，反正有**分配担保机制**。对老年代采用标记-整理算法。新生代里面的对象朝生夕灭，选择复制算法，**复制成本很低**。而老年代的对象存活率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须使用标记-整理算法。

### 垃圾收集器

serial收集器、parNew收集器、parallel scavenge、CMS、G1

#### serial收集器

发生stop the world，串行，虚拟机运行在client模式下默认的新生代收集器，简单高效，没有线程交互的开销。收集一个上百兆的新生代，能够在几十毫秒搞定，只要不是频繁发生，这个时间还是可以接受的。

#### parNew收集器

serial的多线程版本，其他都一样，包括stop the world。新生代采用复制算法，虚拟机运行在server模式下默认的新生代收集器。除了serial，只有parNew会与CMS进行配合工作。

#### parallel scavenge

看上去几乎与parNew一样。关注的是高吞吐量。提供了很多参数，在手工优化存在困难的情况下，只需要设置一个基本的内存数据-Xmx，再设置一个最大停顿时间或者吞吐量。

#### serial old 收集器

#### parallel old 收集器

parallel scavenge可以与parallel old搭配，在注重吞吐量和CPU敏感的场所。

#### CMS 收集器

获取最短停顿时间为目标。初始标记-并发标记-重新标记-并发清除。

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g899sysfdyj30za0fo751.jpg)

优点：并发收集、低停顿。

缺点：1、对CPU资源敏感，占用CPU资源，使得应用程序非常慢，吞吐量降低。2、无法处理浮动垃圾，因为是并发的，运行过程中，用户线程还会不断有新的垃圾产生，这部分垃圾只能等到下一次收集。3、内存碎片问题。标记-清楚算法，解决方案：有参数可以进行配置，顶不住的时候进行full gc时开启一次内存碎片的合并整理，执行多少次不带压缩的FULL GC之后，跟着来一次带压缩的FULL GC（默认是0，每次FULL GC都会进行碎片整理）。4、需要预留一部分空间用于存放并行收集的程序运作使用，预留的内存无法满足时，concurrent mode failure，启动后备预案：临时启动serial old收集器来进行老年代的垃圾收集。总结：这些缺点就是CMS调优的方向。

#### G1收集器

并行与并发、分代收集、标记-整理、可预测的停顿时间（追求低停顿外）建立停顿时间模型，能让使用者指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不操作N毫秒。

#### jdk11的ZGC

停顿时间更低。

## 性能监控和工具

jps\jstat\jmap\jinfo\jstack

### Visual vm

JDK最全的运行监控和故障处理工具。监控CPU、堆、GC、方法区和线程的信息。dump已经分析堆转储快照、方法级的程序运行性能分析。可以安装插件比方说btrace，采用了代码热替换hotswap。profile，跟踪每个方法占用CPU的时间。现存对象都有哪些，占用了多少内存，可以发现可疑的内存泄漏对象。

## 类加载过程

加载-验证-准备-解析-初始化。加载-连接-初始化。

### 加载

获得类的二进制字节流；

字节流代表的静态存储结构转换为方法区的运行时数据结构；

在内存中生成一个class对象，作为访问方法区这些数据的入口。

### 验证

### 准备

为类变量分配内存，并且初始化为零值。、

### 解析

符号引用替换为直接应用。

### 初始化

类变量进行赋值，执行clinit方法。有且只有5中情况才能对类进行初始化。

> 1、new一个类，读取一个静态字段（**未被final修饰**），或者调用一个静态方法；
>
> 2、反射调用
>
> 3、初始化一个类，如果其父类未被初始化，则先触发该父类的初始化
>
> 4、当虚拟机启动，用户需要执行一个主类，包含main方法的那个类
>
> 5、当使用 JDK1.7 的动态动态语言时，如果一个 MethodHandle 实例的最后解析结构为 REF_getStatic、REF_putStatic、REF_invokeStatic、的方法句柄，并且这个句柄没有初始化，则需要先触发器初始化。
>
> PS：第一条中**未被final修饰**，如果是static final 修饰的变量在编译阶段会存入调用类的常量池，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

## 双亲委派模型

保证了程序的稳定运行。

双亲委派模型被破坏，jndi，代码热替换，模块热部署。

## JVM调优

### OOM

一般的手段是通过内存映像分析工具mat对dump出来的堆转存快照进行分析，重点是确认内存中的对象是否是有必要的，也就是为了区分发生了内存溢出还是内存泄漏，如果是内存泄漏，那就要看泄漏对象到GC ROOTS的引用链，导致垃圾收集器无法回收。掌握了对象类型并且GC ROOTS引用链的信息，就可以精确的定位到泄漏代码的位置。如果不存在泄漏，换句话说，对象是必须存在，这个时候得检查机器内存，是否有必要增加-Xmx -Xms，从代码中检查哪些对象是否存在生命周期过长，占用着内存，迟迟未释放，比方说使用了本地缓存等等。

案例：线上出现CPU报警，内存报警，通过jstat发现内存增长速度非常快，minor GC回收效率非常低，基本上放到了老年代，full gc频率非常高。

> 1、让运维dump堆转存快照，我这边用mat分析，发现byte数组占用量特别多，继续看了下引用链，发现通过OKHTTP引用着，迟迟不释放，发生了内存溢出。
>
> 2、二话不说，让运行增加堆最大内存，1.6个G 增加到3个G，治标不治本；
>
> 3、因为CPU报警，是不是某些线程有点问题。我们用命令找到了耗时最高的线程，一直占用着CPU资源，一看也是跟OKHTTP相关，证实了之前的快照分析的判断。
>
> ~~~java
> "OkHttp ConnectionPool" #4858 daemon prio=5 os_prio=0 tid=0x00007f8199496800 nid=0x20a8 in Object.wait() [0x00007f812691c000]
>    java.lang.Thread.State: TIMED_WAITING (on object monitor)
> at java.lang.Object.wait(Native Method)
> at java.lang.Object.wait(Object.java:460)
> at com.squareup.okhttp.ConnectionPool$1.run(ConnectionPool.java:101)
> - locked <0x000000068dba8960> (a com.squareup.okhttp.ConnectionPool)
> at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
> at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
> at java.lang.Thread.run(Thread.java:748)
> ~~~
>
> **线程的状态是TIME_WAITING，是消耗CPU的。这就是CPU飙高的原因。**
>
> 结论：这段时间内，业务量激增，身份证认证的接口请求次数比之前有数量级别的暴增，最重要的是这个接口需要传身份证的照片（byte数组），需要使用OKHTTP调用第三方，连接池都被用完了，进行了阻塞，byte数组一直被引用着，无法释放，导致内存暴增，线程也不能释放，一直占用着CPU资源，应用变得很卡。
>
> 解决方案：身份证照片信息进行压缩、异步、服务降级、部署双节点进行分流处理。

### 调优案例

CMS容易出现concurrent mode failure，GC就会降级，启动后备方案，使用stop the world的serial old垃圾收集器。线上开启gc日志，观察concurrent mode failure出现的次数，如果很多的话，需要进行调优。

出现cmf无非就是两种情况：1、monior gc后，新生代放不下，直接进入老年代，老年代虽然有空间，但是缺少连续的空间，因为采用的标记-清除算法，担保失败（promotion failed）不得不提前full gc（降级为serial old），有个参数可以开启标记-整理算法，发生full gc会进行碎片合并，每次full GC 碎片都要合并整理，停顿时间变长了，于是又有个参数多少次未整理的full gc，来一次碎片整理。2、有业务线程还在运行状态，会产生大的对象，直接放入老年代，老年代放不下，老年代一般都会预留一部分空间留给业务线程使用，解决方案，调低触发CMS GC执行的阈值，参数可以进行设置。-----总结：使用标记整理清除算法和提早进行CMS GC操作。

### JVM线上故障排查基本操作

#### CPU飙高

思路：首先找到CPU飙高的那个java进程，然后再找到进程下面的某个线程，最后进行jstack。

1. 通过top命令找到CPU消耗最高的那个进程，并记住进程ID；
2. 再次通过top -Hp ID 找到CPU消耗最高的线程ID，并记住线程ID；
3. jstack-l ID >jstack.log
4. 线程id是十进制的，jstack需要用到十六进制，需要进行转化
5. 打印出线程堆栈，就能知道些端倪。

一般是某个业务发生了死循环。

#### 内存问题排查

两种情况：内存溢出、内存没有溢出，但是GC不健康。

- 发生内存溢出时输出dump文件，用分析工具进行分析，比方说MAT等等，这些工具能够看出到底是哪里溢出，哪里创建了大量的对象。**这边需要区分内存溢出和内存泄漏！**

- YGC 5秒一次左右，每次不超过50毫秒，CMS GC一天一次左右。

  如果YGC频率很高，适当增加Eden区的大小，但整个新生代的容量应该在堆的30-40%之间。

  如果YGC时间过长，两个过程：扫描和复制，扫描速度很快，复制相对慢一些，如果每次都有大量对象要复制，将会STW时间延长，可否考虑把长命的大对象直接放入老年代。

- FGC的原因有几个，1是老年代区内存不够，2是元数据区内存不够，3是system.gc()，4是jmap，5 cms promotion failed或者concurrent mode failure，6 jvm基于悲观策略认为这次YGC后old区无法容纳晋升的对象，因此取消YGC，提前FGC。一般优化的点是第一个。如果FGC后还有大量对象，说明old区过小，应该扩大old区，如果FGC后效果很好，说明OLD区存在了大量的短命对象，优化点应该让这些对象在新生代就被YGC掉，通常的做法是**增大新生代**，如果有**大而短命的对象**，通过参数设置对象的大小，不要让这些对象进入old区，还需要检查**晋升年龄**是否过小。如果YGC后，有大量对象因为无法进入survivor去从而提前晋升，这时应该**增大survivor区**，但不宜过大。

#### JVM--参数调优

-Xms、-Xmx、Xmn、永久代大小（取消了）、Xms（一般是256k）、Eden和survivor的比例、晋升老年代的年龄、多大的对象直接在老年代分配、TLAB占eden区的百分比

使用垃圾回收器的相关参数。使用CMS、多少次后进行内存压缩、在full gc时候，对老年代进行压缩、预留空间的大小、



## 补充

### 逃逸分析与栈上分配

[参考](https://mp.weixin.qq.com/s/gtKysPvVoTvtu_cApvZHAg)

逃逸分析简单来讲就是，**虚拟机可以分析新创建对象的使用范围，并决定是否在堆上分配内存的一项技术。**

对象逃逸状态

> 1. 全局逃逸
> 2. 参数逃逸
> 3. 没有逃逸：可以进行优化，锁消除，比方说对stringbuffer。标量替换。栈上分配，生命周期和方法一样，随着栈帧的出栈而销毁，减少了GC的压力，提高了应用程序的性能。

总结：逃逸分析是为了优化JVM内存和提升程序性能。在平时开发过程中就要尽可能的**控制变量的作用范围**，变量范围越小越好，让虚拟机尽可能有优化的空间。

